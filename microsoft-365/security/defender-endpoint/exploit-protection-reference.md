---
title: Odwołanie do ochrony przed wykorzystywaniem luk
keywords: środki zaradcze, luki, luki, środki zaradcze, luki w zabezpieczeniach, luki, luki w zabezpieczeniach, emet
description: Szczegółowe informacje na temat działania funkcji ochrony przed wykorzystywaniem luk w zabezpieczeniach Windows
ms.pagetype: security
ms.prod: m365-security
ms.mktglfcycl: manage
ms.sitesec: library
ms.localizationpriority: medium
audience: ITPro
author: denisebmsft
ms.author: deniseb
ms.reviewer: cjacks
manager: dansimp
ms.custom: asr
ms.technology: mde
ms.topic: article
ms.collection: m365initiative-m365-defender
ms.date: 10/19/2021
ms.openlocfilehash: 68e0a855ce23991a90eae36d4ae34245a051bd81
ms.sourcegitcommit: bae72428d229827cba4c807d9cd362417afbcccb
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 02/02/2022
ms.locfileid: "63009822"
---
# <a name="exploit-protection-reference"></a>Odwołanie do ochrony przed luki w zabezpieczeniach

[!INCLUDE [Microsoft 365 Defender rebranding](../../includes/microsoft-defender.md)]


**Dotyczy:**
- [Microsoft Defender for Endpoint Plan 2](https://go.microsoft.com/fwlink/?linkid=2154037)
- [Microsoft 365 Defender](https://go.microsoft.com/fwlink/?linkid=2118804)

> Chcesz mieć dostęp do programu Microsoft Defender dla punktu końcowego? [Zarejestruj się, aby korzystać z bezpłatnej wersji próbnej.](https://signup.microsoft.com/create-account/signup?products=7f379fee-c4f9-4278-b0a1-e4c8c2fcdf7e&ru=https://aka.ms/MDEp2OpenTrial?ocid=docs-wdatp-enablesiem-abovefoldlink)

Ochrona przed wykorzystywaniem luk zapewnia zaawansowaną ochronę aplikacji, które mogą być Pro stosowane po skompilowaniu i rozpowszechnianiu oprogramowania przez dewelopera.

Ten artykuł pomaga zrozumieć, jak działa ochrona przed wykorzystywaniem luk, zarówno na poziomie zasad, jak i poziomu indywidualnego środki zaradczego, aby ułatwić pomyślne tworzenie i stosowanie zasad ochrony przed wykorzystywaniem luk.

## <a name="how-mitigations-are-applied"></a>Jak stosowane są środki zaradcze

Środki zaradcze dotyczące ochrony przed zagrożeniami w przypadku wykorzystywania luk w zabezpieczeniach stosowane są dla 1 aplikacji.

Środki zaradcze są konfigurowane za pośrednictwem wpisu rejestru dla każdego programu, dla który konfigurujesz zabezpieczenia. Te ustawienia są przechowywane w wpisie rejestru **MitigationOptions** dla każdego programu (**HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Image File Execution Options \ *ImageFileName* \ MitigationOptions**). Zajmą się one po ponownym uruchomieniu programu i będą obowiązywać do momentu ich zmiany i ponownego uruchomienia programu.

> [!IMPORTANT]
> Opcje wykonywania pliku obrazu pozwalają jedynie określić nazwę pliku lub ścieżkę, a nie numer wersji, architekturę czy inny inny typ informacji. Uważaj na środki zaradcze dla aplikacji, które mają unikatowe nazwy lub ścieżki, stosując je tylko na urządzeniach, na których została przetestowana ta wersja i ta architektura aplikacji.

Jeśli skonfigurujesz środki zaradcze przed użyciem ochrony przed użyciem pliku konfiguracji XML za pośrednictwem programu PowerShell, programu zasady grupy lub usługi MDM, podczas przetwarzania tego pliku konfiguracji języka XML zostaną skonfigurowane indywidualne ustawienia rejestru.

Jeśli zasady rozmieszczania pliku XML nie są już wymuszane, ustawienia wdrożone w tym pliku konfiguracji XML nie zostaną automatycznie usunięte. Aby usunąć ustawienia ochrony przed luki w zabezpieczeniach, wyeksportuj konfigurację języka XML Windows 10 lub Windows urządzenia z systemem 11, a następnie wdeksportuj ten nowy plik XML. Ewentualnie firma Microsoft udostępnia plik XML jako część planu bazowego programu Zabezpieczenia Windows na Zabezpieczenia Windows ustawień ochrony przed luki w zabezpieczeniach.

Aby zresetować ustawienia ochrony przed wykorzystywaniem luk w zabezpieczeniach przy użyciu programu PowerShell, możesz użyć następującego polecenia:

```powershell
Set-ProcessMitigation -PolicyFilePath EP-reset.xml
```
Poniżej przedstawiono EP-reset.xml względem linii Zabezpieczenia Windows podstawowych:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<MitigationPolicy>
  <AppConfig Executable="ONEDRIVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR OverrideRelocateImages="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
  </AppConfig>
  <AppConfig Executable="firefox.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
  </AppConfig>
  <AppConfig Executable="fltldr.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="GROOVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="Acrobat.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="AcroRd32.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="chrome.exe">
    <DEP OverrideDEP="false" />
  </AppConfig>
  <AppConfig Executable="EXCEL.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="iexplore.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="INFOPATH.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="java.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaw.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaws.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="LYNC.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSACCESS.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSPUB.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OIS.EXE">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OUTLOOK.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="plugin-container.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="POWERPNT.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="PPTVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VISIO.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VPREVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="WINWORD.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wmplayer.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wordpad.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
</MitigationPolicy>
```

## <a name="mitigation-reference"></a>Odwołanie do środków zaradczych

W poniższych sekcjach opisano zabezpieczenia zapewniane przez poszczególne środki zaradcze związane z ochroną przed zagrożeniami, zagadnienia dotyczące zgodności związane z tym ograniczeniem i dostępne opcje konfiguracji.

## <a name="arbitrary-code-guard"></a>Dowolny kod guard

### <a name="description"></a>Opis

Dowolnego zabezpieczenia kodów pomagają chronić przed złośliwym atakiem i załadowaniem wybranego przez nich kodu do pamięci przez lukę w zabezpieczeniach pamięci i możliwość wykonywania tego kodu.

Dowolny kod guard chroni aplikację przed dynamicznie generowanym kodem (kod, który nie jest ładowany na przykład z samego pliku exe lub biblioteki dll). Dowolna ochrona kodu działa przez zapobieganie oznaczaniu pamięci jako pliku wykonywalnego. Gdy aplikacja próbuje przydzielić [pamięć](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc), sprawdzamy flagi ochrony. (Pamięć można przydzielać przy użyciu flag ochrony przed odczytaniem, zapisem i/lub wykonywaniem). Jeśli alokacja spróbuje uwzględnić flagę [*ochrony wykonywania*](/windows/win32/memory/memory-protection-constants) , alokacja pamięci zakończy się niepowodzeniem i zostanie zwracany kod błędu (STATUS_DYNAMIC_CODE_BLOCKED). Podobnie jeśli aplikacja spróbuje zmienić flagi ochrony pamięci, która została już przydzielona i zawiera [flagę](/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) ochrony wykonywania, zmiana [](/windows/win32/memory/memory-protection-constants) uprawnień zakończy się niepowodzeniem i zwróci kod błędu (STATUS_DYNAMIC_CODE_BLOCKED).

Zapobiegając ustawianiu *flagi* wykonywania, funkcja ochrony przed wykonaniem danych programu Windows 10 i Windows 11 może następnie chronić się przed ustawieniem wskaźnika instrukcji do tej pamięci i uruchomieniem tego kodu.

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Dowolny kod guard zapobiega przydzieleniu wszelkiej pamięci jako pliku wykonywalnego, co występuje problem ze zgodnością w przypadku takich metod, jak programy kompilacji just-in-time (JIT). Na przykład większość nowoczesnych przeglądarek będzie kompilować język JavaScript na kod natywny w celu zoptymalizowania wydajności. Aby wspierać ten czynnik zaradczy, należy ponownie przechować kompilację JIT poza chroniony proces. Inne aplikacje, których projekt dynamicznie generuje kod z skryptów lub innych języków pośrednich, będą w podobny sposób niezgodne z tym ograniczeniem.

### <a name="configuration-options"></a>Opcje konfiguracji

**Zezwalaj na rezygnację z wątku** — możesz skonfigurować środki zaradcze, aby zezwolić pojedynczeowi wątek na zrezygnowanie z tej ochrony. Deweloper musi napisane aplikację z poinformowaniem o tym czynniku zaradczym i mieć nazwę interfejsu API [**SetThreadInformation**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation) z parametrem *ThreadInformation* ustawionym na wartość **ThreadDynamicCodePolicy** , aby umożliwić wykonywanie kodu dynamicznego w tym wątku.

**Tylko inspekcja** — możesz włączyć ten wpływ na inspekcję w celu mierzenia potencjalnego wpływu zgodności na aplikację. Zdarzenia inspekcji można następnie wyświetlać w podglądzie zdarzeń lub za pomocą zaawansowanego wyszukiwania w [programie Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="block-low-integrity-images"></a>Blokowanie obrazów o niskiej integralności

### <a name="description"></a>Opis

Zablokuj obrazy o niskiej integralności, aby zapobiec ładowaniu przez aplikację plików niezaufanych, zwykle dlatego, że zostały one pobrane z Internetu z przeglądarki w trybie piaskownicy.

Ten środki zaradcze zablokuje ładowanie obrazu, jeśli obraz ma wpis kontroli dostępu (ACE), który udziela dostępu do procesów Low IL, a który nie ma etykiety zaufania ACE. Jest on implementowany przez menedżera pamięci, co blokuje mapowane pliku na pamięć. Jeśli aplikacja spróbuje zamapować obraz o niskiej integralności, wyzwoli błąd STATUS_ACCESS_DENIED integralności. Aby uzyskać szczegółowe informacje na temat sposobu działania poziomów integralności, zobacz [Obowiązkowa kontrola integralności](/windows/win32/secauthz/mandatory-integrity-control).

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Zablokuj obrazy o niskiej integralności, aby zapobiec ładowaniu przez aplikację plików pobranych z Internetu. Jeśli przepływ pracy aplikacji wymaga ładowania pobranych obrazów, należy się upewnić, że są one pobierane z procesu wyższego zaufania lub są jawnie ponownie określone w celu zastosowania tego ograniczenia.

### <a name="configuration-options"></a>Opcje konfiguracji

**Tylko inspekcja** — możesz włączyć to ograniczenie w trybie inspekcji w celu oceny potencjalnego wpływu zgodności na aplikację. Zdarzenia inspekcji można następnie wyświetlać w przeglądarce zdarzeń lub za pomocą zaawansowanego wyszukiwania w programie [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="block-remote-images"></a>Blokowanie obrazów zdalnych

### <a name="description"></a>Opis

Blokowanie obrazów zdalnych pomaga zapobiec ładowaniu przez aplikację plików hostowanych na urządzeniu zdalnym, takim jak udział UNC. Blokowanie obrazów zdalnych pomaga chronić przed ładowaniem danych binralnych do pamięci, które znajdują się na urządzeniu zewnętrznym kontrolowanym przez atakującego.

Ten czynnik zaradczy zablokuje ładowanie obrazu, jeśli obraz jest określony jako na urządzeniu zdalnym. Jest on implementowany przez menedżera pamięci, co blokuje mapowane pliku na pamięć. Jeśli aplikacja spróbuje zamapować plik zdalny, wyzwoli błąd STATUS_ACCESS_DENIED zdalny.

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Zablokuj obrazy zdalne, aby uniemożliwić aplikacji ładowanie obrazów z urządzeń zdalnych. Jeśli aplikacja ładuje pliki lub wtyczki z urządzeń zdalnych, nie będzie ona zgodna z tym ograniczeniem.

### <a name="configuration-options"></a>Opcje konfiguracji

**Tylko inspekcja** — możesz włączyć to ograniczenie w trybie inspekcji w celu oceny potencjalnego wpływu zgodności na aplikację. Zdarzenia inspekcji można następnie wyświetlać w przeglądarce zdarzeń lub za pomocą zaawansowanego wyszukiwania w programie [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="block-untrusted-fonts"></a>Blokowanie niezaufanych czcionek

### <a name="description"></a>Opis

Zablokowanie niezaufanych czcionek ogranicza ryzyko wystąpienia błędu podczas analizowania czcionek prowadzącego do tego, że atakujący może uruchomić kod na urządzeniu. Do przetwarzania przez GDI zostaną załadowane tylko czcionki zainstalowane w katalogu windows\fonts.

Ten czynnik zaradczy jest implementowany w obrębie GDI, co sprawdza lokalizację pliku. Jeśli plik nie znajduje się w katalogu czcionek systemowych, czcionka nie zostanie załadowana do analizy i to wywołanie nie powiedzie się.

Ten środki zaradcze jest dodatkiem do wbudowanego środki zaradczego dostępnego w programie Windows 10 1607 i nowszych oraz Windows 11, który przenosi analizowanie czcionek z kernel i do kontenera aplikacji w trybie użytkownika. Wykorzystywanie luk opartych na analizowaniu czcionek w rezultacie odbywa się w piaskownicy i w odizolowanym kontekście, co znacznie zmniejsza ryzyko. Aby uzyskać szczegółowe informacje na temat tego ograniczenia, zobacz blog [Ograniczanie Windows 10 z bezdniowymi ograniczeniami wykorzystywania.](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/)

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Najczęściej używane czcionki spoza katalogu czcionek systemowych są używane z [czcionkami internetowymi](/typography/fonts/font-faq#web). Nowoczesne przeglądarki, takie jak Microsoft Edge, używają DirectWrite gdi i nie mają wpływu. Jednak w starszych przeglądarkach, takich jak program Internet Explorer 11 (i tryb programu Internet Explorer w nowym Microsoft Edge), może to mieć wpływ szczególnie w przypadku aplikacji, takich jak Office 365, w których do wyświetlania interfejsu użytkownika są używane symboly czcionek.

### <a name="configuration-options"></a>Opcje konfiguracji

**Tylko inspekcja** — możesz włączyć to ograniczenie w trybie inspekcji w celu oceny potencjalnego wpływu zgodności na aplikację. Zdarzenia inspekcji można następnie wyświetlać w przeglądarce zdarzeń lub za pomocą zaawansowanego wyszukiwania w programie [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="code-integrity-guard"></a>Ochrona integralności kodu

### <a name="description"></a>Opis

Ochrona integralności kodu gwarantuje, że wszystkie pliki binarne załadowane do procesu są podpisane cyfrowo przez firmę Microsoft. W ramach ochrony integralności kodu są dostępne podpisy [WHQL](/windows-hardware/drivers/install/whql-release-signature) (Windows Hardware Quality Labs), które umożliwiają uruchamianie zatwierdzonych sterowników WHQL w ramach tego procesu.

Ten środki zaradcze jest implementowany w menedżerze pamięci, co blokuje mapowane dane binarne na pamięć. Jeśli spróbujemy załadować dane binarne, które nie są podpisane przez firmę Microsoft, schowek pamięci zwróci błąd STATUS_INVALID_IMAGE_HASH. Zablokowanie na poziomie menedżera pamięci zapobiega zarówno załadowaniu danych binralnych przez proces, jak i czasników binralnych do procesu.

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Ten środki zaradcze blokuje w szczególności wszystkie pliki binarne, które nie są podpisane przez firmę Microsoft. Z tego względu będzie ono niezgodne z większości programów innych firm, chyba że to oprogramowanie jest rozpowszechniane przez firmę Microsoft Store i podpisywane cyfrowo oraz jest zaznaczona opcja zezwalania na ładowanie obrazów podpisanych przez Microsoft Store.

### <a name="configuration-options"></a>Opcje konfiguracji

Zezwalaj też na ładowanie obrazów podpisanych przez firmę **Microsoft Store** — aplikacje rozpowszechniane przez Microsoft Store będą podpisane cyfrowo przez Microsoft Store, a dodanie tej konfiguracji umożliwi ładowanie przez aplikację plików binralnych, które przeszło przez proces certyfikacji sklepu.

**Tylko inspekcja** — możesz włączyć to ograniczenie w trybie inspekcji w celu oceny potencjalnego wpływu zgodności na aplikację. Zdarzenia inspekcji można następnie wyświetlać w przeglądarce zdarzeń lub za pomocą zaawansowanego wyszukiwania w programie [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="control-flow-guard-cfg"></a>Control flow guard (CFG)

### <a name="description"></a>Opis

Funkcja control flow guard (CFG, Control flow guard) ogranicza ryzyko atakujących korzystających z luk w uszkodzeniach pamięci przez ochronę pośrednich wywołań funkcji. Na przykład atakujący może użyć luki w zabezpieczeniach przed przepełnieniami buforu w celu zastąpienia pamięci zawierającej wskaźnik funkcji i zastąpienia go wskaźnikiem funkcji wskaźnikiem wykonywalnego kodu wybranego przez użytkownika (który mógł zostać także przysłany w programie).

Ten środki zaradcze jest zapewniany przez wsadowanie kolejnego sprawdzania w czasie kompilowania. Przed każdym pośrednim wywołaniem funkcji są dodawane kolejne instrukcje, które sprawdzają, czy element docelowy jest prawidłowym elementem docelowym wywołania przed jego wywołaniem. Jeśli element docelowy nie jest prawidłowym obiektem docelowym połączenia, aplikacja zostaje zakończona. W związku z tym z tego środki zaradcze mogą korzystać tylko aplikacje skompilowane przy użyciu obsługi CFG.

Sprawdzanie prawidłowego obiektu docelowego jest udostępniane przez Windows. Gdy pliki wykonywalne są ładowane, metadane dla pośrednich celów połączeń są wyodrębnione podczas ładowania i oznaczane jako prawidłowe cele połączeń. Ponadto po przydzieleniu i oznaczniu pamięci jako pliku wykonywalnego (na przykład dla wygenerowanego kodu) te lokalizacje pamięci są również oznaczane jako prawidłowe cele wywołań w celu obsługi mechanizmów, takich jak kompilacja JIT.

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Ze względu na to, że aplikacje muszą być skompilowane w celu obsługi cfg, niejawnie deklarują swoją zgodność z nim. Większość aplikacji powinna więc pracować z włączonym takim ograniczeniem. Ponieważ te testy są skompilowane w postaci binarnej, można jedynie wyłączyć testy w tym Windows binarnym. Innymi słowy, środki zaradcze są domyślnie włączone, ale możesz skonfigurować ją tak Windows, aby zawsze zwracała wartość "tak", jeśli później ustalisz problem ze zgodnością, który deweloper aplikacji nie wykrył podczas testowania, co powinno być rzadkie.

### <a name="configuration-options"></a>Opcje konfiguracji

**Używaj ścisłego cfg** — w trybie strict wszystkie pliki binralne załadowane do procesu muszą być skompilowane dla funkcji Control Flow Guard (lub nie mają w nich kodu wykonywalnego — na przykład bibliotek dll zasobów) w celu załadowania.

> [!Note]
> **Ochrona przepływu sterowania** nie ma trybu inspekcji. Pliki binarne są skompilowane z włączonym takim ograniczeniem.

## <a name="data-execution-prevention-dep"></a>Zapobieganie wykonywaniu danych (DEP)

### <a name="description"></a>Opis

Zapobieganie wykonywaniu danych (DEP) zapobiega wykonywaniu pamięci, która nie została jawnie przydzielona jako plik wykonywalny. Funkcja DEP pomaga chronić atakującego, który dodaje złośliwy kod do procesu, na przykład przez przepełnienie buforem, a następnie wykonywać ten kod.

Jeśli spróbujemy ustawić wskaźnik instrukcji na adres pamięci, który nie jest oznaczony jako wykonywalny, procesor zgłasza wyjątek (naruszenie ogólnej ochrony), powodując awarię aplikacji.

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Wszystkie pliki wykonywalne x64, ARM i pliki ARM-64 mają domyślnie włączony funkcja DEP i nie można jej wyłączyć. Ponieważ aplikacja nie będzie nigdy wykonywana bez funkcji DEP, zakłada się zgodność.

Wszystkie urządzenia dwubarwne x86 (32-bitowe) domyślnie mają włączoną funkcję DEP, ale funkcję DEP można wyłączyć dla procesów. Niektóre starsze aplikacje, zwykle aplikacje opracowane przed programem Windows XP z dodatkiem SP2, mogą być niezgodne z funkcją DEP. Takie aplikacje zazwyczaj dynamicznie generują kod (na przykład kompilowanie JIT) lub link do starszych bibliotek (takich jak starsze wersje atL), które dynamicznie generują kod.

### <a name="configuration-options"></a>Opcje konfiguracji

**Włącz emulację thunk ATL** — ta opcja konfiguracji wyłącza emulację ATL Thunk. Biblioteka szablonów szablonów ActiveX ATL została zaprojektowana tak, aby był jak najmniejszy i szybki. Aby zmniejszyć rozmiar dwójkowy, należy użyć techniki o *nazwie thunking*. Typowa różnica polega na tym, że należy korzystać z interakcji między aplikacjami 32-bitową i 16-bitową, ale nie ma tu 16-bitowych składników do instalacji ATL. Zamiast tego w celu zoptymalizowania pod kątem rozmiaru dwójkowego atL będzie przechowywać kod maszynowy w pamięci, który nie jest wyrównany do wyrazów (tworząc mniejszy plik binarny), a następnie wywoła ten kod bezpośrednio. Składniki ATL skompilowane z programem Visual Studio 7.1 lub wcześniejszym (Visual Studio 2003) nie przydzielają tej pamięci jako pliku wykonywalnego — emulacja thunk rozwiązuje ten problem ze zgodnością. Aplikacje, które mają binarny model rozszerzenia (taki jak Internet Explorer 11), często muszą mieć włączoną emulację ATL Thunk.

## <a name="disable-extension-points"></a>Wyłączanie punktów rozszerzenia

### <a name="description"></a>Opis

Ten środki zaradcze wyłącza różne punkty rozszerzenia dla aplikacji, które mogą być używane do ustanawiania zachowywania lub wynasyłania uprawnień złośliwej zawartości.

Obejmuje to:

- **Biblioteki DLL AppInit** — przy każdym uruchamianiu procesu system załaduje określoną bibliotekę DLL do kontekstu nowo uruchomionego procesu przed wywołaniem funkcji punktu wejścia. [Szczegółowe informacje na temat bibliotek DLL AppInit można znaleźć tutaj](/windows/win32/winmsg/about-window-classes#application-global-classes). Gdy stosowane jest to ograniczenie, biblioteki DLL appinit nie są ładowane. Począwszy od Windows 7 biblioteki DLL AppInit muszą być podpisane cyfrowo, zgodnie z [opisem w tym miejscu](/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2). Ponadto, począwszy od Windows 8, biblioteki DLL AppInit nie zostaną załadowane, jeśli funkcja SecureBoot jest włączona, zgodnie z [opisem w tym miejscu](/windows/win32/dlls/secure-boot-and-appinit-dlls).
- **Starsze wiadomości błyskawiczne** — edytor IME (Input Method Editor) pozwala użytkownikowi wpisywać tekst w języku, który ma więcej znaków niż może być reprezentowanych na klawiaturze. Inne firmy mogą tworzyć wiadomości błyskawiczne. Złośliwy plik IME może uzyskać poświadczenia lub inne poufne informacje z tego przechwytywania danych wejściowych. Niektóre wiadomości błyskawiczne, nazywane starszymi wiadomościami błyskawicznymi, będą działać tylko w Windows klasycznych, a nie w aplikacjach UWP. Ten środki zaradcze uniemożliwi również ładowanie tego starszegome IME do określonej Windows klasycznej.
- **Windows połączeń zdarzeń** — aplikacja może wywołać interfejs [API SetWinEventHook](/windows/win32/api/winuser/nf-winuser-setwineventhook), aby zarejestrować zainteresowanie zdarzeniem. Biblioteka DLL jest określona i można ją dodać do procesu. Ten czynnik zaradczy wymusza naciąganie podłączania do procesu rejestrowania, a nie uruchamianie w trakcie procesu przy użyciu biblioteki DLL.

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Większość tych punktów rozszerzenia jest stosunkowo rzadko używana, więc wpływ na zgodność jest zazwyczaj mały, szczególnie na poziomie poszczególnych aplikacji. Jedną z nich jest zastosowanie w przypadku używania starszych wiadomości błyskawicznych innych firm, które nie będą działać z chronioną aplikacją.

### <a name="configuration-options"></a>Opcje konfiguracji

Nie ma żadnych opcji konfiguracji dla tego środki zaradczego.

> [!Note]
> **Wyłącz punkty rozszerzenia bez** trybu inspekcji.

## <a name="disable-win32k-system-calls"></a>Wyłączanie połączeń systemowych Win32k

### <a name="description"></a>Opis

Win32k.sys udostępnia szeroki zakres ataków dla atakującego. Jako składnik trybu kernelgo jest często ukierunkowany jako wektor ucieczki dla aplikacji w trybie piaskownicy. Ten środki zaradcze zapobiega wywoływaniu win32k.sys przez zablokowanie wątku przekonwertowania się na wątek graficznego interfejsu użytkownika, który następnie uzyskuje dostęp do funkcji win32k. Utworzono wątek bez graficznego interfejsu użytkownika, ale konwertowany w pierwszym wywołaniu na win32k.sys lub za pomocą wywołania interfejsu API do [IsGuiThread](/windows/win32/api/winuser/nf-winuser-isguithread).

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Ten czynnik zaradczy jest przeznaczony dla procesów, które są dedykowanymi procesami niezwiązywami z interfejsem użytkownika. Na przykład wiele nowoczesnych przeglądarek korzysta z izolacji procesu i zawiera procesy niezwiązywne z interfejsem użytkownika. Ten czynnik zaradczy ma wpływ na każdą aplikację, która wyświetla interfejs UŻYTKOWNIKA przy użyciu pojedynczego procesu.

### <a name="configuration-options"></a>Opcje konfiguracji

**Tylko inspekcja** — możesz włączyć to ograniczenie w trybie inspekcji w celu oceny potencjalnego wpływu zgodności na aplikację. Zdarzenia inspekcji można następnie wyświetlać w przeglądarce zdarzeń lub za pomocą zaawansowanego wyszukiwania w programie [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="do-not-allow-child-processes"></a>Nie zezwalaj na procesy podrzędne

### <a name="description"></a>Opis

Ten środki zaradcze zapobiega tworzeniu nowych aplikacji podrzędnej przez aplikację. Często używaną techniką adversaries jest zainicjowanie zaufanego procesu na urządzeniu za pomocą złośliwych danych wejściowych (atak "na ziemi"), który często wymaga uruchomienia innej aplikacji na urządzeniu. Jeśli nie ma żadnych uzasadnionych powodów, dla których aplikacja uruchomi proces podrzędny, to ograniczenie ogranicza ryzyko potencjalnego wektora ataków. Środki zaradcze są stosowane przez ustawienie właściwości tokenu procesu, która blokuje tworzenie tokenu dla procesu podrzędnego przy użyciu komunikatu o błędzie STATUS_CHILD_PROCESS_BLOCKED.

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Jeśli aplikacja z jakiegokolwiek powodu uruchamia aplikacje podrzędne, takie jak hiperlinki, które uruchamiają przeglądarkę lub przeglądarkę zewnętrzną albo które uruchamiają inne narzędzia na komputerze, ta funkcja zostanie przerwana, gdy zostanie zastosowany ten zaradczy.

### <a name="configuration-options"></a>Opcje konfiguracji

**Tylko inspekcja** — możesz włączyć to ograniczenie w trybie inspekcji w celu oceny potencjalnego wpływu zgodności na aplikację. Zdarzenia inspekcji można następnie wyświetlać w przeglądarce zdarzeń lub za pomocą zaawansowanego wyszukiwania w programie [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="export-address-filtering"></a>Filtrowanie adresów eksportu

### <a name="description"></a>Opis

Filtrowanie adresów eksportu (EAF, Export Address Filtering) ogranicza ryzyko złośliwego kodu patrzącego na tabelę adresów eksportu wszystkich załadowanych modułów w celu znalezienia modułów zawierających przydatne interfejsy API do ich ataków. Jest to częsty emotikon używany przez kod powłoki. Aby zminimalizować ryzyko takiego ataku, ten środki zaradcze chroni trzy często zaatakowane moduły:

- ntdll.dll
- kernelbase.dll
- kernel32.dll

Środki zaradcze chronią stronę pamięci w [katalogu eksportu, który wskazuje [tabelę adresów eksportu](/windows/win32/debug/pe-format#export-address-table). Do tej strony pamięci zostanie [PAGE_GUARD](/windows/win32/memory/creating-guard-pages) ochrony komputera. Gdy ktoś spróbuje uzyskać dostęp do tej pamięci, wygeneruje STATUS_GUARD_PAGE_VIOLATION. Środki zaradcze obsługują ten wyjątek i jeśli instrukcja dostępu nie przejdzie przez sprawdzanie poprawności, proces zostanie zakończony.

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Ten środek zaradczy jest przede wszystkim problemem dla aplikacji, takich jak debugery, aplikacje w trybie piaskownicy, aplikacje korzystające z zabezpieczeń DRM lub aplikacje implementują technologię przeciw debugowania.

### <a name="configuration-options"></a>Opcje konfiguracji

**Sprawdzanie poprawności dostępu do modułów, które** są często używane przez luki w zabezpieczeniach — ta opcja, znana również jako EAF+, dodaje zabezpieczenia dla innych często zaatakowanych modułów:

- `mshtml.dll`
- `flash*.ocx`
- `jscript*.ocx`
- `vbscript.dll`
- `vgx.dll`
- `mozjs.dll`
- `xul.dll`
- `acrord32.dll`
- `acrofx32.dll`
- `acroform.api`

Ponadto włączenie funkcji EAF+, tej opcji zaradczej powoduje dodanie ochrony PAGE_GUARD do strony zawierającej nagłówek "MZ", czyli pierwszych dwóch bajtów nagłówka [DOS](/windows/win32/debug/pe-format#ms-dos-stub-image-only) w pliku PE, który jest innym aspektem znanej zawartości pamięci, który kod powłoki może znaleźć w celu zidentyfikowania modułów potencjalnie interesującego w pamięci.

**Tylko inspekcja** — możesz włączyć to ograniczenie w trybie inspekcji w celu oceny potencjalnego wpływu zgodności na aplikację. Zdarzenia inspekcji można następnie wyświetlać w przeglądarce zdarzeń lub za pomocą zaawansowanego wyszukiwania w programie [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="force-randomization-for-images-mandatory-aslr"></a>Wymuszaj losowanie obrazów (obowiązkowy JSW)

### <a name="description"></a>Opis

Randomizacja układu przestrzeni adresowej (ASLR, Address Space Layout Randomization) ogranicza ryzyko atakującego korzystającego z jego wiedzy na temat układu pamięci systemu w celu wykonania kodu, który znajduje się już w pamięci procesu i został już oznaczony jako plik wykonywalny. Może to zmniejszyć ryzyko wystąpienia atakującego przy użyciu technik, takich jak ataki typu return-to-libc, gdy narzędzie adversary określa kontekst, a następnie modyfikuje adres zwrotny w celu wykonania istniejącego kodu w kontekście pasym do przeznaczenia adversary.

Obowiązkowa aslr wymusza ponowne bazy wszystkich bibliotek DLL w ramach procesu. Deweloper może włączyć funkcję ASLR przy użyciu [opcji łączy /DYNAMICBASE](/cpp/build/reference/dynamicbase-use-address-space-layout-randomization) i ten wpływ ma ten sam wpływ.

Gdy Menedżer pamięci mapuje obraz na obrazie na ten proces, obowiązkowy aslr spowoduje ponowne użycie bibliotek DLL i plików EXE, które nie wybrały opcji ASLR. Pamiętaj jednak, że takie ponowne naniesienie nie ma entropów i dlatego może być umieszczone w przewidywalnej lokalizacji w pamięci. W przypadku ponownej lokalizacji i losowej lokalizacji danych binralnych ten czynnik zaradczy powinien być sparowany z alokacjami pamięci losowej (Od dołu do góry [ASLR).](#randomize-memory-allocations-bottom-up-aslr)

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Ten wpływ na zgodność funkcji ASLR jest zwykle ograniczony do starszych aplikacji zbudowanych przy użyciu programów programowych, które miały założenia dotyczące podstawowego adresu pliku binarnego lub zostały zdjęty z informacji o podstawowych przeniesieniach. Może to prowadzić do nieprzewidywalnych błędów, gdy przepływ wykonywania próbuje przejść do oczekiwanego, a nie rzeczywistego położenia w pamięci.

### <a name="configuration-options"></a>Opcje konfiguracji

**Nie zezwalaj na przycięte obrazy** — ta opcja blokuje ładowanie obrazów, które miały informacje o przeniesieniach, zostały zdjęte. Format pliku pe programu Windows PE zawiera adresy bezwzględne, a program kompigljący generuje również tabelę [bazowego adresu odniesienia), która może zostać wykorzystać do odnalezienia wszystkich względnych odwołań do pamięci i ich przesunięć, co pozwala na ich zaktualizowanie, jeśli plik binarny nie ładuje się przy preferowanym adresie bazowym. Niektóre starsze aplikacje wyebrały te informacje w kompilacjach produkcyjnych, dlatego tych binr nie można zmienić. Ten środki zaradcze blokuje ładowanie takiego binariusza (zamiast zezwalać na ładowanie przy preferowanym adresie bazowym).

> [!Note]
> **Wymusz losowanie obrazów (obowiązkowy JSW) nie** ma trybu inspekcji.

## <a name="import-address-filtering-iaf"></a>Importowanie filtrowania adresów (IAF)

### <a name="description"></a>Opis

Ograniczenie filtrowania adresów importu (IAF, import address filtering) pomaga zmniejszyć ryzyko zmiany przepływu kontroli aplikacji przez zmianę przepływu sterowania przez zmodyfikowanie tabeli adresów importu w celu przekierowania do dowolnego kodu wyboru atakującego, gdy ta funkcja jest nazywana. Atakujący może używać tego podejścia do kontrolowania lub przechwycenia, sprawdzania i potencjalnego blokowania połączeń z poufnymi interfejsami API.

Do stron pamięci wszystkich chronionych interfejsów API będą [PAGE_GUARD](/windows/win32/memory/creating-guard-pages) ochrony. Gdy ktoś spróbuje uzyskać dostęp do tej pamięci, wygeneruje STATUS_GUARD_PAGE_VIOLATION. Środki zaradcze obsługują ten wyjątek i jeśli instrukcja dostępu nie przejdzie przez sprawdzanie poprawności, proces zostanie zakończony.

Ten środki zaradcze chroni następujące Windows API:

- `GetProcAddress`
- `GetProcAddressForCaller`
- `LoadLibraryA`
- `LoadLibraryExA`
- `LoadLibraryW`
- `LoadLibraryExW`
- `LdrGetProcedureAddress`
- `LdrGetProcedureAddressEx`
- `LdrGetProcedureAddressForCaller`
- `LdrLoadDll`
- `VirtualProtect`
- `VirtualProtectEx`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `NtProtectVirtualMemory`
- `CreateProcessA`
- `CreateProcessW`
- `WinExec`
- `CreateProcessAsUserA`
- `CreateProcessAsUserW`
- `GetModuleHandleA`
- `GetModuleHandleW`
- `RtlDecodePointer`
- `DecodePointer`

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Wiarygodne aplikacje, które przechwycą interfejs API, mogą zostać wykryte przez ten czynnik zaradczy i powodować awarie niektórych aplikacji. Przykłady obejmują zabezpieczenia oprogramowania i funkcje zgodności aplikacji.

### <a name="configuration-options"></a>Opcje konfiguracji

**Tylko inspekcja** — możesz włączyć to ograniczenie w trybie inspekcji w celu oceny potencjalnego wpływu zgodności na aplikację. Zdarzenia inspekcji można następnie wyświetlać w przeglądarce zdarzeń lub za pomocą zaawansowanego wyszukiwania w programie [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="randomize-memory-allocations-bottom-up-aslr"></a>Randomizuj alokacje pamięci (Od dołu do góry ASLR)

### <a name="description"></a>Opis

Losowe alokacje pamięci (Od dołu do góry ASLR) dodają entropy do przydziałów, więc ich lokalizacja jest losowo i przez to mniej przewidywalna. To ograniczenie wymaga, aby działanie obowiązkowych aslr było skuteczne.

Rozmiar 32-bitowej przestrzeni adresowej stanowi praktyczne ograniczenia dotyczące entropów, które można dodać, dlatego aplikacje 64-bitowe utrudnią osobie atakującej odgadywanie lokalizacji w pamięci.

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Większość aplikacji zgodnych z obowiązkową funkcją ASLR (ponowne zastosowanie) jest również zgodna z innym entropy'em bottom-up ASLR. Niektóre aplikacje mogą mieć problemy z obcięciem wskaźnika, jeśli zapisują wskaźniki lokalne w zmiennych 32-bitowych (oczekiwanie na adres podstawowy poniżej 4 GB), a zatem będą niezgodne z opcją wysokiego entropii (którą można wyłączyć).

### <a name="configuration-options"></a>Opcje konfiguracji

**Nie** używaj wysokiego astrofu — ta opcja wyłącza użycie wysokiej entropyjności ASLR, co powoduje dodanie 24 bitów entropy (1 TB wariancji) do alokacji dolnej dla aplikacji 64-bitowych.

> [!Note]
> **Losowe alokacje pamięci (Od dołu do góry ASLR) nie** mają trybu inspekcji.

## <a name="simulate-execution-simexec"></a>Symulowanie wykonywania (SimExec)

### <a name="description"></a>Opis

Symulowanie wykonywania (SimExec) jest środki zaradcze tylko dla aplikacji 32-bitowych. Pozwala to zweryfikować, czy połączenia z poufnymi interfejsami API powrócą do legalnych funkcji wywołującego. Pozwala to przechwycić wywołania do poufnych interfejsów API, a następnie symulować ich wykonywanie, przechodząc przez zakodowane instrukcje języka zestawu poszukujące instrukcji RET, która powinna zostać zwrócona wywołującej. Następnie przeprowadza inspekcję tej funkcji i cofa się w pamięci, znajdź poprzednie instrukcje wywołań w celu określenia, czy funkcja i wywołaj instrukcję są zgodne, oraz czy RET nie został przecięcia.

Interfejsy API przechwycone przez ten czynnik zaradczy są:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

W przypadku wykrycia gadżetu CHCESZ proces zostaje zakończony.

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Aplikacje, które wykonują przechwytywanie interfejsu API, szczególnie oprogramowanie zabezpieczające, mogą powodować problemy ze zgodnością przy tym zaradczym.

Ten środki zaradcze jest niezgodny z ograniczeniem dowolnej ochrony kodu.

### <a name="configuration-options"></a>Opcje konfiguracji

**Tylko inspekcja** — możesz włączyć to ograniczenie w trybie inspekcji w celu oceny potencjalnego wpływu zgodności na aplikację. Zdarzenia inspekcji można następnie wyświetlać w przeglądarce zdarzeń lub za pomocą zaawansowanego wyszukiwania w programie [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="validate-api-invocation-callercheck"></a>Sprawdzanie poprawności wywołania interfejsu API (CallerCheck)

### <a name="description"></a>Opis

Sprawdź, czy wywołanie interfejsu API (CallerCheck) ma zawężenie dla technik programowania zorientowanego na zwracanie (ABY) sprawdzać, czy poufne interfejsy API zostały wywoływane z prawidłowego wywołującego. Ten parametr zasłania przekazany adres zwrotny, a następnie przeprowadza deasemmetrię odwrotną, aby znaleźć połączenie powyżej adresu zwrotowego w celu określenia, czy element docelowy połączenia jest zgodny z parametrem przekazanym do funkcji.

Interfejsy API przechwycone przez ten czynnik zaradczy są:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

W przypadku wykrycia gadżetu CHCESZ proces zostaje zakończony.

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Aplikacje, które wykonują przechwytywanie interfejsu API, szczególnie oprogramowanie zabezpieczające, mogą powodować problemy ze zgodnością przy tym zaradczym.

Ten środki zaradcze jest niezgodny z ograniczeniem dowolnej ochrony kodu.

### <a name="configuration-options"></a>Opcje konfiguracji

**Tylko inspekcja** — możesz włączyć to ograniczenie w trybie inspekcji w celu oceny potencjalnego wpływu zgodności na aplikację. Zdarzenia inspekcji można następnie wyświetlać w przeglądarce zdarzeń lub za pomocą zaawansowanego wyszukiwania w programie [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="validate-exception-chains-sehop"></a>Weryfikowanie łańcuchów wyjątków (SEHOP)

### <a name="description"></a>Opis

Sprawdź, czy łańcuchy wyjątków (SEHOP) mają zaradczy dla metody obsługi wyjątków strukturalnych *(SEH, Structured Exception Handler) zastępowania* techniki wykorzystywania. [Uporządkowana obsługa wyjątków](/windows/win32/debug/structured-exception-handling) to proces, w którym aplikacja może poprosić o obsługę określonego wyjątku. Programy obsługi wyjątków są połączone w łańcuch, dzięki czemu jeśli obsługa wyjątków nie będzie obsługiwać określonego wyjątku, może być przekazywana do następnego uchwytu wyjątków w łańcuchu, dopóki jedna z nich nie zdecyduje się na jej obsługę. Lista programu obsługi jest dynamiczna, dlatego jest przechowywana w stosie. Atakujący może użyć luki w zabezpieczeniach przed przepełnieniem stosu w celu zastąpienia programu obsługi wyjątków wskaźnikiem wyboru atakującego.

Ten środki zaradcze zależy od projektu protokołu SEH, gdzie każdy wpis SEH zawiera zarówno wskaźnik obsługi wyjątków, jak i wskaźnik następnego programu obsługi w łańcuchu wyjątków. Ten czynnik zaradczy jest wywoływany przez wysyłającego wyjątek, który sprawdza łańcuch SEH po wywołaniu wyjątku. Sprawdza ono, czy:

- Wszystkie rekordy łańcucha wyjątków znajdują się wewnątrz granic stosów
- Wszystkie rekordy wyjątków są wyrównane
- Wskaźniki obsługi wyjątków nie wskazują stosu
- Nie ma żadnych wskaźników do tyłu
- Łańcuch wyjątków kończy się znanym końcowym programem obsługi wyjątków

Jeśli te weryfikacje się nie powiodą, obsługa wyjątków zostanie przerwana i wyjątek nie zostanie obsługiwany.

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Problemy ze zgodnością dotyczące urządzenia SEHOP są stosunkowo rzadkie. Aplikacja często ma zależność od uszkodzenia łańcucha wyjątków. Jednak niektóre aplikacje mają wpływ na delikatne zmiany w chronometrażu, które mogą wystąpić jako warunek wyścigu, który odsłoni w aplikacji wielowątkową usterkę.

### <a name="configuration-options"></a>Opcje konfiguracji

> [!Note]
> **Sprawdź, czy łańcuchy wyjątków (SEHOP) nie** mają trybu inspekcji.

## <a name="validate-handle-usage"></a>Sprawdzanie poprawności użycia uchwytu

### <a name="description"></a>Opis

*Sprawdzanie poprawności użycia uchwytu* to środki zaradcze chroniące przed atakującym, korzystając z istniejącego uchwytu w celu uzyskania dostępu do obiektu chronionego. Uchwyt [jest](/windows/win32/sysinfo/handles-and-objects) odwołaniem do chronionego obiektu. Jeśli kod aplikacji odwołuje się do nieprawidłowego uchwytu, może to wskazywać, że adversary próbuje użyć poprzednio zarejestrowanego uchwytu (ale którego odwołania do aplikacji nie powinien wiedzieć). Jeśli aplikacja spróbuje użyć nieprawidłowego obiektu, zamiast po prostu zwracać wartość null, aplikacja podniesie wyjątek (STATUS_INVALID_HANDLE).

To ograniczenie jest automatycznie stosowane do aplikacji Windows Store.

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Ten czynnik zaradczy może mieć wpływ na aplikacje, które nie dokładnie śledziły odwołań i które nie zawijały tych operacji za pomocą programów obsługi wyjątków.

### <a name="configuration-options"></a>Opcje konfiguracji

> [!Note]
> **Sprawdź, czy użycie uchwytu** nie ma trybu inspekcji.

## <a name="validate-heap-integrity"></a>Sprawdzanie integralności stosu

### <a name="description"></a>Opis

Ograniczenie *integralności heap* zwiększa poziom ochrony przed zagrożeniami Windows, powodując zakończenie aplikacji w przypadku wykrycia uszkodzenia stosu. Środki zaradcze są następujące:

- Uniemożliwianie wolnej pracy uchwytu HEAP
- Sprawdzanie poprawności kolejnych nagłówków rozszerzonych bloków dla przydziałów po hejt.
- Sprawdzanie, czy przydziały stosu nie są już oflagowane jako podczas używania
- Dodawanie stron do ochrony przed dużymi alokacjami, segmentami łęgów i podsektami powyżej minimalnego rozmiaru

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Ten środki zaradcze jest już stosowany domyślnie w aplikacjach 64-bitowych i w przypadku aplikacji 32-bitowych, których wartość jest Windows Vista lub nowszym. Starsze aplikacje z Windows XP lub starszych są najbardziej ryzykowne, chociaż problemy ze zgodnością występują rzadko.

### <a name="configuration-options"></a>Opcje konfiguracji

> [!Note]
> **Sprawdź integralność stosu nie** ma trybu inspekcji.

## <a name="validate-image-dependency-integrity"></a>Sprawdzanie integralności współzależności obrazów

### <a name="description"></a>Opis

Ograniczanie *zależności od obrazów* pomaga zabezpieczyć się przed atakami, które próbują zastąpić kod bibliotek dll, które są statyczne połączone przez Windows binaries. Technika blokowania bibliotek DLL polega na nadużyciach mechanizmu wyszukiwania modułu wyszukiwania w celu wsadu złośliwego kodu, który może być używany do uruchamiania złośliwego kodu w podwyższonym kontekście. Gdy ładowanie ładuje plik binarny z podpisem Windows, a następnie ładowane są wszystkie biblioteki dll, od których zależy plik binarny, te pliki binarne zostaną zweryfikowane w celu zagwarantowania, że są one również podpisane cyfrowo jako pliki Windows binarne. Jeśli nie będą sprawdzać podpisu, biblioteka dll nie zostanie załadowana i będzie zgłaszać wyjątek, zwracając stan biblioteki STATUS_INVALID_IMAGE_HASH.

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Problemy ze zgodnością są rzadkością. Aplikacje, które zależą od zastąpienia Windows binaryki lokalnymi wersjami prywatnymi, będą miały wpływ, a ponadto istnieje niewielkie ryzyko ujawnienia subtelnych błędów chronometrażu w aplikacjach wielowątkowych.

### <a name="configuration-options"></a>Opcje konfiguracji

**Tylko inspekcja** — możesz włączyć to ograniczenie w trybie inspekcji w celu oceny potencjalnego wpływu zgodności na aplikację. Zdarzenia inspekcji można następnie wyświetlać w przeglądarce zdarzeń lub za pomocą zaawansowanego wyszukiwania w programie [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="validate-stack-integrity-stackpivot"></a>Sprawdzanie integralności stosu (StackPivot)

### <a name="description"></a>Opis

Środki zaradcze dotyczące integralności stosu *(StackPivot)* pomagają chronić przed atakami ze stosu przestawnego, atakami, w trakcie których atakujący tworzą fałszywy stos w pamięci, a następnie infekuje powracanie aplikacji do fałszywego stosu, który steruje przepływem wykonywania.

Ten środki zaradcze przechwytuje Windows interfejsów API i sprawdza wartość wskaźnika stosu. Jeśli adres wskaźnika stosu nie należy do dołu ani między dolną krawędzią stosu, oznacza to, że zdarzenie jest rejestrowane i, jeśli nie jest w trybie inspekcji, proces zostanie zakończony.

Interfejsy API przechwycone przez ten czynnik zaradczy są:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

### <a name="compatibility-considerations"></a>Zagadnienia dotyczące zgodności

Aplikacje używające fałszywych stosów mogą mieć wpływ, a ponadto istnieje niewielkie ryzyko ujawnienia drobnych błędów chronometrażu w aplikacjach wielowątkowych.
Aplikacje, które wykonują przechwytywanie interfejsu API, szczególnie oprogramowanie zabezpieczające, mogą powodować problemy ze zgodnością przy tym zaradczym.

Ten środki zaradcze jest niezgodny z ograniczeniem dowolnej ochrony kodu.

### <a name="configuration-options"></a>Opcje konfiguracji

**Tylko inspekcja** — możesz włączyć to ograniczenie w trybie inspekcji w celu oceny potencjalnego wpływu zgodności na aplikację. Zdarzenia inspekcji można następnie wyświetlać w przeglądarce zdarzeń lub za pomocą zaawansowanego wyszukiwania w programie [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).
